{"version":3,"file":"static/chunks/5748.f6a31d63a20c56f3.js","mappings":"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","sources":["webpack://_N_E/../ui-core/src/util/hashObject.ts","webpack://_N_E/../ui-core/src/app/FeatureFlags.oss.tsx","webpack://_N_E/../ui-core/src/app/Flags.tsx","webpack://_N_E/../ui-core/src/hooks/useStateWithStorage.tsx","webpack://_N_E/../../node_modules/@vx/shape/esm/shapes/link/diagonal/LinkVertical.js","webpack://_N_E/../ui-core/src/util/idb-lru-cache.ts","webpack://_N_E/../../node_modules/lodash/memoize.js","webpack://_N_E/../ui-core/src/app/DefaultFeatureFlags.oss.tsx","webpack://_N_E/../ui-core/src/util/weakMapMemoize.ts","webpack://_N_E/../ui-core/src/workers/WorkerThread.oss.ts"],"sourcesContent":["import {weakMapMemoize} from './weakMapMemoize';\n\n/**\n * Creates a fast deterministic hash from a large JSON object iteratively\n * @param obj - The JSON object to hash (must not contain circular references)\n * @returns A deterministic hash string\n */\nexport const hashObject = weakMapMemoize((obj: any): string => {\n  // Using MurmurHash3\n  let h1: number = 0x12345678; // Seed\n\n  // Constants for MurmurHash3\n  const c1: number = 0xcc9e2d51;\n  const c2: number = 0x1b873593;\n\n  // Faster hash update function (based on MurmurHash3)\n  function hashChunk(str: string): void {\n    let k1: number;\n\n    // Process string in 4-byte chunks for speed\n    for (let i = 0; i < str.length; i += 4) {\n      // Pack up to 4 bytes into a 32-bit int\n      k1 = 0;\n      const remaining = Math.min(4, str.length - i);\n      for (let j = 0; j < remaining; j++) {\n        k1 |= str.charCodeAt(i + j) << (j * 8);\n      }\n\n      // MurmurHash3 algorithm\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);\n      h1 = h1 * 5 + 0xe6546b64;\n    }\n  }\n\n  // Use a more efficient stack representation with fewer objects\n  // Each object creation is expensive, so we'll reuse objects where possible\n  const TYPE_PRIMITIVE = 0;\n  const TYPE_ARRAY = 1;\n  const TYPE_OBJECT = 2;\n\n  interface StackItem {\n    type: number; // 0=primitive, 1=array, 2=object\n    value: any; // The actual value\n    keys?: string[]; // Sorted keys for objects\n    index: number; // Current index in array/keys\n    state: number; // 0=start, 1=processing, 2=done\n  }\n\n  // Initial stack with just the root object\n  const stack: StackItem[] = [\n    {\n      type:\n        typeof obj === 'object' && obj !== null\n          ? Array.isArray(obj)\n            ? TYPE_ARRAY\n            : TYPE_OBJECT\n          : TYPE_PRIMITIVE,\n      value: obj,\n      index: 0,\n      state: 0,\n    },\n  ];\n\n  // Small string buffer to avoid creating too many strings\n  const smallBuffer = ['{', '}', '[', ']', ':', ',', 'null', 'true', 'false'] as const;\n\n  // Process the object iteratively\n  while (stack.length > 0) {\n    const current = stack[stack.length - 1]!;\n\n    // Start processing a new item\n    if (current.state === 0) {\n      current.state = 1;\n\n      // Process based on type\n      if (current.type === TYPE_PRIMITIVE) {\n        if (current.value === null) {\n          hashChunk(smallBuffer[6]); // 'null'\n        } else if (typeof current.value === 'boolean') {\n          hashChunk(current.value ? smallBuffer[7] : smallBuffer[8]); // 'true' or 'false'\n        } else if (typeof current.value === 'number') {\n          // Use a consistent string representation for numbers\n          hashChunk(current.value.toString());\n        } else if (typeof current.value === 'string') {\n          hashChunk(current.value);\n        }\n        current.state = 2; // Mark as done\n      } else if (current.type === TYPE_ARRAY) {\n        hashChunk(smallBuffer[2]); // '['\n\n        if (current.value.length === 0) {\n          hashChunk(smallBuffer[3]); // ']'\n          current.state = 2; // Mark as done\n        }\n      } else if (current.type === TYPE_OBJECT) {\n        hashChunk(smallBuffer[0]); // '{'\n\n        // Sort keys once and cache them\n        current.keys = Object.keys(current.value).sort();\n\n        if (current.keys.length === 0) {\n          hashChunk(smallBuffer[1]); // '}'\n          current.state = 2; // Mark as done\n        }\n      }\n    }\n    // Process array/object elements\n    else if (current.state === 1) {\n      if (current.type === TYPE_ARRAY) {\n        const arr = current.value;\n\n        if (current.index > 0) {\n          hashChunk(smallBuffer[5]); // ','\n        }\n\n        if (current.index < arr.length) {\n          const item = arr[current.index++];\n          const itemType =\n            item === null || typeof item !== 'object'\n              ? TYPE_PRIMITIVE\n              : Array.isArray(item)\n                ? TYPE_ARRAY\n                : TYPE_OBJECT;\n\n          // Push the item onto the stack\n          stack.push({\n            type: itemType,\n            value: item,\n            index: 0,\n            state: 0,\n          });\n        } else {\n          // Finished processing array\n          hashChunk(smallBuffer[3]); // ']'\n          current.state = 2;\n        }\n      } else if (current.type === TYPE_OBJECT) {\n        const keys = current.keys!;\n\n        if (current.index > 0) {\n          hashChunk(smallBuffer[5]); // ','\n        }\n\n        if (current.index < keys.length) {\n          const key = keys[current.index++]!;\n          hashChunk(key);\n          hashChunk(smallBuffer[4]); // ':'\n\n          const item = current.value[key];\n          const itemType =\n            item === null || typeof item !== 'object'\n              ? TYPE_PRIMITIVE\n              : Array.isArray(item)\n                ? TYPE_ARRAY\n                : TYPE_OBJECT;\n\n          // Push the item onto the stack\n          stack.push({\n            type: itemType,\n            value: item,\n            index: 0,\n            state: 0,\n          });\n        } else {\n          // Finished processing object\n          hashChunk(smallBuffer[1]); // '}'\n          current.state = 2;\n        }\n      }\n    }\n    // Finished with this item\n    else {\n      stack.pop();\n    }\n  }\n\n  // Finalize the hash (MurmurHash3 finalization)\n  h1 ^= h1 >>> 16;\n  h1 = (h1 * 0x85ebca6b) >>> 0;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 * 0xc2b2ae35) >>> 0;\n  h1 ^= h1 >>> 16;\n\n  return h1.toString(16).padStart(8, '0');\n});\n","export enum FeatureFlag {\n  flagDebugConsoleLogging = 'flagDebugConsoleLogging',\n  flagDisableWebsockets = 'flagDisableWebsockets',\n  flagSidebarResources = 'flagSidebarResources',\n  flagDisableAutoLoadDefaults = 'flagDisableAutoLoadDefaults',\n  flagAssetNodeFacets = 'flagAssetNodeFacets',\n  flagUseNewObserveUIs = 'flagUseNewObserveUIs',\n  flagMarketplace = 'flagMarketplace',\n  flagDocsInApp = 'flagDocsInApp',\n  flagAssetRetries = 'flagAssetRetries',\n\n  // Flags for tests\n  __TestFlagDefaultNone = '__TestFlagDefaultNone',\n  __TestFlagDefaultTrue = '__TestFlagDefaultTrue',\n  __TestFlagDefaultFalse = '__TestFlagDefaultFalse',\n}\n","import {useEffect, useState} from 'react';\nimport {DEFAULT_FEATURE_FLAG_VALUES} from 'shared/app/DefaultFeatureFlags.oss';\nimport {FeatureFlag} from 'shared/app/FeatureFlags.oss';\n\nimport {getJSONForKey} from '../hooks/useStateWithStorage';\n\nexport const DAGSTER_FLAGS_KEY = 'DAGSTER_FLAGS';\n\nexport const WEB_WORKER_FEATURE_FLAGS_KEY = '__featureFlags';\n\n/**\n * Type representing the mapping of feature flags to their boolean states.\n */\ntype FeatureFlagMap = Partial<Record<FeatureFlag, boolean>>;\n\n/**\n * In-memory cache for feature flags, excludes default values.\n */\nlet currentFeatureFlags: FeatureFlagMap = {};\n\n/**\n * Initialize the in-memory cache by loading from localStorage and handling migration.\n */\nconst initializeFeatureFlags = () => {\n  let flags = getJSONForKey(DAGSTER_FLAGS_KEY);\n\n  // Handle backward compatibility by migrating array to object\n  if (Array.isArray(flags)) {\n    const migratedFlags: FeatureFlagMap = {};\n    flags.forEach((flag: FeatureFlag) => {\n      migratedFlags[flag] = true;\n    });\n    setFeatureFlagsInternal(migratedFlags);\n    flags = migratedFlags;\n  }\n\n  currentFeatureFlags = flags || {};\n};\n\n/**\n * Internal function to set feature flags without broadcasting.\n * Used during initialization and migration and by web-workers.\n */\nexport const setFeatureFlagsInternal = (flags: FeatureFlagMap) => {\n  if (typeof flags !== 'object' || Array.isArray(flags)) {\n    throw new Error('flags must be an object mapping FeatureFlag to boolean values');\n  }\n  currentFeatureFlags = flags;\n  if (typeof localStorage !== 'undefined') {\n    localStorage.setItem(DAGSTER_FLAGS_KEY, JSON.stringify(flags));\n  }\n};\n\n// Initialize the BroadcastChannel\nconst featureFlagsChannel = new BroadcastChannel('feature-flags');\n\n// Initialize feature flags on module load\ninitializeFeatureFlags();\n\nexport const getFeatureFlagsWithoutDefaultValues = (): FeatureFlagMap => {\n  return currentFeatureFlags;\n};\n\nexport const getFeatureFlagDefaults = (): FeatureFlagMap => {\n  return DEFAULT_FEATURE_FLAG_VALUES;\n};\n\nexport const getFeatureFlagsWithDefaults = (): FeatureFlagMap => {\n  return {...DEFAULT_FEATURE_FLAG_VALUES, ...currentFeatureFlags};\n};\n\n/**\n * Function to check if a specific feature flag is enabled.\n * Falls back to default values if the flag is unset.\n */\nexport const featureEnabled = (flag: FeatureFlag): boolean => {\n  if (flag in currentFeatureFlags) {\n    return currentFeatureFlags[flag]!;\n  }\n\n  // Return default value if flag is unset\n  return DEFAULT_FEATURE_FLAG_VALUES[flag] ?? false;\n};\n\n/**\n * Hook to access feature flags within React components.\n * Returns a flag map with resolved values (considering defaults).\n */\nexport const useFeatureFlags = (): Readonly<Record<FeatureFlag, boolean>> => {\n  const [flags, setFlags] = useState<Record<FeatureFlag, boolean>>(() => {\n    const allFlags: Partial<Record<FeatureFlag, boolean>> = {};\n\n    for (const flag in FeatureFlag) {\n      const key = flag as FeatureFlag;\n      if (key in currentFeatureFlags) {\n        allFlags[key] = currentFeatureFlags[key];\n      } else {\n        allFlags[key] = DEFAULT_FEATURE_FLAG_VALUES[key] ?? false;\n      }\n    }\n    return allFlags as Record<FeatureFlag, boolean>;\n  });\n\n  useEffect(() => {\n    const handleFlagsChange = () => {\n      const allFlags: Partial<Record<FeatureFlag, boolean>> = {};\n\n      for (const flag in FeatureFlag) {\n        const key = flag as FeatureFlag;\n        if (key in currentFeatureFlags) {\n          allFlags[key] = currentFeatureFlags[key];\n        } else {\n          allFlags[key] = DEFAULT_FEATURE_FLAG_VALUES[key] ?? false;\n        }\n      }\n      setFlags(allFlags as Record<FeatureFlag, boolean>);\n    };\n\n    // Listen for messages from the BroadcastChannel\n    featureFlagsChannel.addEventListener('message', handleFlagsChange);\n\n    return () => {\n      featureFlagsChannel.removeEventListener('message', handleFlagsChange);\n    };\n  }, []);\n\n  return flags;\n};\n\n/**\n * Function to update feature flags.\n * Updates the in-memory cache, persists to localStorage, and broadcasts the change.\n */\nexport const setFeatureFlags = (flags: FeatureFlagMap) => {\n  setFeatureFlagsInternal(flags);\n  featureFlagsChannel.postMessage('updated');\n};\n\nexport const toggleFeatureFlag = (flag: FeatureFlag) => {\n  const flags = getFeatureFlagsWithDefaults();\n  flags[flag] = !flags[flag];\n  setFeatureFlags(flags);\n  featureFlagsChannel.postMessage('updated');\n};\n","import * as React from 'react';\n\nexport function getJSONForKey(key: string) {\n  let stored = undefined;\n  try {\n    if (typeof window === 'undefined') {\n      stored = self.localStorage.getItem(key);\n    } else {\n      stored = window.localStorage.getItem(key);\n    }\n    if (stored) {\n      return JSON.parse(stored);\n    }\n  } catch {\n    if (typeof stored === 'string') {\n      // With useStateWithStorage, some values like timezone are moving from `UTC` to `\"UTC\"`\n      // in LocalStorage. To read the old values, pass through raw string values. We can\n      // remove this a few months after 0.14.1 is released.\n      return stored;\n    }\n    return undefined;\n  }\n}\n\nconst DID_WRITE_LOCALSTORAGE = '';\n\nexport function useStateWithStorage<T>(key: string, validate: (json: any) => T) {\n  const [version, setVersion] = React.useState(0);\n\n  const validateRef = React.useRef(validate);\n  validateRef.current = validate;\n\n  const listener = React.useCallback(\n    (event: Event) => {\n      if (event instanceof CustomEvent && event.detail === key) {\n        setVersion((v) => v + 1);\n      }\n    },\n    [key],\n  );\n\n  React.useEffect(() => {\n    document.addEventListener(DID_WRITE_LOCALSTORAGE, listener);\n    return () => document.removeEventListener(DID_WRITE_LOCALSTORAGE, listener);\n  }, [listener]);\n\n  // Note: This hook doesn't keep the loaded data in state -- instead it uses a version bit and\n  // a ref to load the value from localStorage when the `key` changes or when the `version` changes.\n  // This allows us to immediately return the saved value for `key` in the same render.\n\n  const state = React.useMemo(() => {\n    return validate(getJSONForKey(key));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [validate, key, version]);\n\n  const setStateInner = React.useCallback(\n    (next: T | undefined) => {\n      if (next === undefined) {\n        window.localStorage.removeItem(key);\n      } else {\n        window.localStorage.setItem(key, JSON.stringify(next));\n      }\n      document.removeEventListener(DID_WRITE_LOCALSTORAGE, listener);\n      document.dispatchEvent(new CustomEvent(DID_WRITE_LOCALSTORAGE, {detail: key}));\n      document.addEventListener(DID_WRITE_LOCALSTORAGE, listener);\n\n      setVersion((v) => v + 1);\n\n      return next;\n    },\n    [key, listener],\n  );\n\n  const setState = React.useCallback(\n    (input: React.SetStateAction<T>) => {\n      const next =\n        input instanceof Function ? input(validateRef.current(getJSONForKey(key))) : input;\n      setStateInner(next);\n    },\n    [key, setStateInner],\n  );\n\n  const clearState = React.useCallback(() => {\n    setStateInner(undefined);\n  }, [setStateInner]);\n\n  return [state, setState, clearState] as const;\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from 'react';\nimport cx from 'classnames';\nimport PropTypes from 'prop-types';\nimport { linkVertical } from 'd3-shape';\nexport function pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n  return function (data) {\n    var link = linkVertical();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\nLinkVertical.propTypes = {\n  innerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n  x: PropTypes.func,\n  y: PropTypes.func,\n  source: PropTypes.func,\n  target: PropTypes.func,\n  path: PropTypes.func,\n  className: PropTypes.string,\n  children: PropTypes.func,\n  data: PropTypes.any\n};\nexport default function LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === void 0 ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === void 0 ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === void 0 ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === void 0 ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      children = _ref2.children,\n      restProps = _objectWithoutPropertiesLoose(_ref2, [\"className\", \"innerRef\", \"data\", \"path\", \"x\", \"y\", \"source\", \"target\", \"children\"]);\n\n  var pathGen = path || pathVerticalDiagonal({\n    source: source,\n    target: target,\n    x: x,\n    y: y\n  });\n  if (children) return children({\n    path: path\n  });\n  return React.createElement(\"path\", _extends({\n    ref: innerRef,\n    className: cx('vx-link vx-link-vertical-diagonal', className),\n    d: pathGen(data)\n  }, restProps));\n}","import debounce from 'lodash/debounce';\n\nimport {LRUCache} from './lru-cache';\n\ninterface CacheOptions {\n  dbName: string;\n  dbVersion?: number;\n  maxCount: number;\n}\n\nclass IDBError extends Error {\n  constructor(\n    message: string,\n    public originalError?: unknown,\n  ) {\n    super(message);\n    this.name = 'IDBError';\n  }\n}\n\n/**\n * A cache that uses IndexedDB to store and retrieve an in-memory LRUCache.\n */\nclass IDBLRUCache<T> {\n  private dbName: string;\n  private maxCount: number;\n  private dbPromise: Promise<IDBDatabase> | undefined;\n  private isDbOpen = false;\n  private lruCache: LRUCache<T>;\n  private dbVersion?: number;\n\n  constructor({dbName, dbVersion, maxCount}: CacheOptions) {\n    this.dbName = `idb-lru-cache-v1-${dbName}`;\n    this.maxCount = maxCount;\n    this.lruCache = new LRUCache<T>(maxCount);\n    this.dbPromise = this.initDB();\n    this.dbVersion = dbVersion;\n  }\n\n  private async initDB(): Promise<IDBDatabase> {\n    const request = indexedDB.open(this.dbName, this.dbVersion);\n\n    return new Promise((resolve, reject) => {\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains('cache')) {\n          db.createObjectStore('cache');\n        }\n      };\n      request.onsuccess = async (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        this.isDbOpen = true;\n\n        // Load the entire cache from IndexedDB\n        const tx = db.transaction('cache', 'readonly');\n        const store = tx.objectStore('cache');\n        const request = store.get('lru-cache');\n\n        await new Promise<void>((resolve, reject) => {\n          request.onsuccess = () => {\n            if (request.result) {\n              this.lruCache = LRUCache.fromJSON(request.result, this.maxCount);\n            }\n            resolve();\n          };\n          request.onerror = () => {\n            reject(new IDBError('Failed to load cache', request.error));\n          };\n        });\n\n        resolve(db);\n      };\n      request.onerror = (event) => {\n        this.isDbOpen = false;\n        reject(new IDBError('Failed to open database', (event.target as IDBOpenDBRequest).error));\n      };\n      request.onblocked = () => {\n        this.isDbOpen = false;\n        reject(new IDBError('Database is blocked'));\n      };\n    });\n  }\n\n  private async withDB<T>(operation: (db: IDBDatabase) => Promise<T>): Promise<T> {\n    try {\n      if (!this.dbPromise) {\n        this.dbPromise = this.initDB();\n      }\n      const db = await this.dbPromise;\n      if (!this.isDbOpen) {\n        throw new IDBError('Database is not open', this.dbName);\n      }\n      return await operation(db);\n    } catch (error) {\n      if (error instanceof IDBError) {\n        throw error;\n      }\n      throw new IDBError('Database operation failed', error);\n    }\n  }\n\n  private syncToDB = debounce(async (): Promise<void> => {\n    return this.withDB(async (db) => {\n      const transaction = db.transaction('cache', 'readwrite');\n      const store = transaction.objectStore('cache');\n\n      await new Promise((resolve, reject) => {\n        const putRequest = store.put(this.lruCache.toJSON(), 'lru-cache');\n        putRequest.onsuccess = () => resolve(void 0);\n        putRequest.onerror = () => reject(new IDBError('Failed to sync cache', putRequest.error));\n      });\n    });\n  }, 1000);\n\n  async set(key: string, value: T): Promise<void> {\n    return this.withDB(async () => {\n      this.lruCache.put(key, value);\n      this.syncToDB();\n    });\n  }\n\n  async get(key: string): Promise<{value: T} | undefined> {\n    return this.withDB(async () => {\n      const value = this.lruCache.get(key);\n      return value !== undefined ? {value} : undefined;\n    });\n  }\n\n  async has(key: string): Promise<boolean> {\n    return this.withDB(async () => {\n      return this.lruCache.get(key) !== undefined;\n    });\n  }\n\n  async delete(key: string): Promise<void> {\n    return this.withDB(async () => {\n      this.lruCache.put(key, undefined as any); // Using put to trigger LRU eviction\n      this.syncToDB();\n    });\n  }\n\n  async clear(): Promise<void> {\n    return this.withDB(async () => {\n      this.lruCache = new LRUCache<T>(this.maxCount);\n      this.syncToDB();\n    });\n  }\n\n  async close(): Promise<void> {\n    await this.syncToDB.flush();\n    await this.withDB(async (db) => {\n      this.isDbOpen = false;\n      delete this.dbPromise;\n      db.close();\n    });\n  }\n}\n\nexport function cache<T>(options: CacheOptions): IDBLRUCache<T> {\n  return new IDBLRUCache<T>(options);\n}\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","import {FeatureFlag} from 'shared/app/FeatureFlags.oss';\n\n/**\n * Default values for feature flags when they are unset.\n */\nexport const DEFAULT_FEATURE_FLAG_VALUES: Partial<Record<FeatureFlag, boolean>> = {\n  [FeatureFlag.flagAssetNodeFacets]: true,\n  [FeatureFlag.flagDocsInApp]: true,\n\n  // Flags for tests\n  [FeatureFlag.__TestFlagDefaultTrue]: true,\n  [FeatureFlag.__TestFlagDefaultFalse]: false,\n};\n","import LRU from 'lru-cache';\n\ntype AnyFunction = (...args: any[]) => any;\n\ninterface WeakMapMemoizeOptions {\n  maxEntries?: number; // Optional limit for cached entries\n  ttl?: number; // Time-To-Live in seconds\n}\n\ninterface CacheNode {\n  map: Map<any, CacheNode>;\n  weakMap: WeakMap<object, CacheNode>;\n  result?: any;\n  parent?: CacheNode;\n  parentKey?: any;\n  lruKey?: any; // Reference to the key in the LRU cache\n  childCount: number; // Number of child nodes\n  timeoutId?: ReturnType<typeof setTimeout>; // Timer for TTL eviction\n}\n\n/**\n * Determines if a value is a non-null object or function.\n * @param value - The value to check.\n * @returns True if the value is a non-null object or function, false otherwise.\n */\nfunction isObject(value: any): value is object {\n  return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\n/**\n * Recursively deletes parent nodes if their childCount reaches zero.\n * @param cacheNode - The cache node to start deletion from.\n */\nfunction recursivelyDeleteParent(cacheNode: CacheNode) {\n  if (cacheNode.parent && cacheNode.parentKey !== undefined) {\n    const parent = cacheNode.parent;\n    const parentKey = cacheNode.parentKey;\n\n    // Remove the current cacheNode from its parent\n    if (isObject(parentKey)) {\n      parent.weakMap.delete(parentKey);\n    } else {\n      parent.map.delete(parentKey);\n    }\n\n    // Clear the TTL timer if set\n    if (cacheNode.timeoutId) {\n      clearTimeout(cacheNode.timeoutId);\n    }\n\n    // Decrement the parent's child count\n    parent.childCount--;\n\n    // If the parent's childCount reaches zero and it's not the root, recurse\n    if (parent.childCount === 0 && parent.parent) {\n      recursivelyDeleteParent(parent);\n    }\n  }\n}\n\n/**\n * Memoizes a function using nested Maps and WeakMaps based on the arguments.\n * Optionally limits the number of cached entries using an LRU cache and sets TTL for cache entries.\n * Handles both primitive and object arguments efficiently.\n * @param fn - The function to memoize.\n * @param options - Optional settings for memoization.\n * @returns A memoized version of the function.\n */\nexport function weakMapMemoize<T extends AnyFunction>(fn: T, options?: WeakMapMemoizeOptions): T {\n  const {maxEntries, ttl} = options || {};\n\n  // Initialize the root cache node\n  const cacheRoot: CacheNode = {\n    map: new Map(),\n    weakMap: new WeakMap(),\n    childCount: 0,\n  };\n\n  // Initialize LRU Cache if maxEntries is specified\n  let lruCache: LRU<any, CacheNode> | null = null;\n\n  if (maxEntries) {\n    lruCache = new LRU<any, CacheNode>({\n      max: maxEntries,\n      dispose: (_key, cacheNode) => {\n        // Remove the cached result\n        delete cacheNode.result;\n\n        // Clear the TTL timer if set\n        if (cacheNode.timeoutId) {\n          clearTimeout(cacheNode.timeoutId);\n        }\n\n        // If there are no child nodes, proceed to remove this node from its parent\n        if (cacheNode.childCount === 0 && cacheNode.parent && cacheNode.parentKey !== undefined) {\n          recursivelyDeleteParent(cacheNode);\n        }\n      },\n      noDisposeOnSet: false, // Ensure dispose is called on eviction\n    });\n  }\n\n  return function memoizedFunction(...args: any[]) {\n    let currentCache = cacheRoot;\n    const path: any[] = [];\n\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      path.push(arg);\n      const isArgObject = isObject(arg);\n\n      let nextCacheNode: CacheNode | undefined;\n\n      if (isArgObject) {\n        if (!currentCache.weakMap.has(arg)) {\n          const newCacheNode: CacheNode = {\n            map: new Map(),\n            weakMap: new WeakMap(),\n            parent: currentCache,\n            parentKey: arg,\n            childCount: 0,\n          };\n          currentCache.weakMap.set(arg, newCacheNode);\n          currentCache.childCount++;\n        }\n        nextCacheNode = currentCache.weakMap.get(arg);\n      } else {\n        if (!currentCache.map.has(arg)) {\n          const newCacheNode: CacheNode = {\n            map: new Map(),\n            weakMap: new WeakMap(),\n            parent: currentCache,\n            parentKey: arg,\n            childCount: 0,\n          };\n          currentCache.map.set(arg, newCacheNode);\n          currentCache.childCount++;\n        }\n        nextCacheNode = currentCache.map.get(arg);\n      }\n\n      currentCache = nextCacheNode!;\n    }\n\n    // After traversing all arguments, check if the result is cached\n    if ('result' in currentCache) {\n      // If using LRU Cache, update its usage\n      if (lruCache && currentCache.lruKey) {\n        lruCache.get(currentCache.lruKey); // This updates the recentness\n      }\n      return currentCache.result;\n    }\n\n    // Compute the result\n    const result = fn(...args);\n\n    // Cache the result\n    currentCache.result = result;\n\n    // If TTL is specified, set a timeout to evict the cache entry\n    if (ttl) {\n      currentCache.timeoutId = setTimeout(() => {\n        // Remove the result\n        delete currentCache.result;\n\n        // Remove from LRU if applicable\n        if (lruCache && currentCache.lruKey) {\n          lruCache.del(currentCache.lruKey);\n        }\n\n        // Recursively delete parent nodes if necessary\n        if (\n          currentCache.childCount === 0 &&\n          currentCache.parent &&\n          currentCache.parentKey !== undefined\n        ) {\n          recursivelyDeleteParent(currentCache);\n        }\n      }, ttl * 1000); // Convert seconds to milliseconds\n    }\n\n    // If LRU cache is enabled, manage the cache entries\n    if (lruCache && !currentCache.lruKey) {\n      const cacheEntryKey = Symbol();\n      currentCache.lruKey = cacheEntryKey; // Associate the cache node with the LRU key\n      lruCache.set(cacheEntryKey, currentCache);\n    }\n\n    return result;\n  } as T;\n}\n","import {WEB_WORKER_FEATURE_FLAGS_KEY, setFeatureFlags} from '../app/Flags';\n\nexport const createWorkerThread = (\n  onMessage: (postMessage: (message: any) => void, data: any) => Promise<void>,\n  onError: (postMessage: (message: any) => void, error: Error, event: MessageEvent) => void,\n) => {\n  self.addEventListener('message', async (event) => {\n    try {\n      if (event.data[WEB_WORKER_FEATURE_FLAGS_KEY]) {\n        setFeatureFlags(event.data[WEB_WORKER_FEATURE_FLAGS_KEY]);\n      } else {\n        await onMessage(self.postMessage, event.data);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        self.postMessage({type: 'error', error: error.message, stack: error.stack});\n      } else {\n        self.postMessage({type: 'error', error: String(error), stack: undefined});\n      }\n      onError(self.postMessage, error as Error, event);\n    }\n  });\n};\n"],"names":["weakMapMemoize","h1","hashChunk","str","k1","i","length","remaining","Math","min","j","charCodeAt","c1","stack","type","obj","Array","isArray","TYPE_ARRAY","value","index","TYPE_OBJECT","state","TYPE_PRIMITIVE","current","smallBuffer","toString","keys","Object","sort","arr","item","itemType","push","key","pop","padStart","FeatureFlag","DAGSTER_FLAGS_KEY","flags","localStorage","setItem","JSON","stringify","BroadcastChannel","initializeFeatureFlags","getJSONForKey","migratedFlags","forEach","flag","setFeatureFlagsInternal","setFeatureFlags","featureFlagsChannel","postMessage","stored","undefined","window","getItem","parse","IDBError","Error","constructor","message","originalError","name","flagAssetNodeFacets","flagDocsInApp","__TestFlagDefaultTrue","__TestFlagDefaultFalse","isObject","recursivelyDeleteParent","cacheNode","parent","parentKey","weakMap","delete","map","timeoutId","childCount","fn","options","maxEntries","ttl","cacheRoot","Map","WeakMap","lruCache","LRU","max","dispose","_key","result","noDisposeOnSet","memoizedFunction","args","currentCache","path","nextCacheNode","arg","isArgObject","has","newCacheNode","set","get","lruKey","setTimeout","del","cacheEntryKey","Symbol","createWorkerThread","onMessage","onError","self","addEventListener","event","data","WEB_WORKER_FEATURE_FLAGS_KEY","error","String"],"sourceRoot":"","ignoreList":[4,6]}