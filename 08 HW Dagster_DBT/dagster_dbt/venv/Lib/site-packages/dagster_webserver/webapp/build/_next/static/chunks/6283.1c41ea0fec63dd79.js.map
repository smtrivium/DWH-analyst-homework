{"version":3,"file":"static/chunks/6283.1c41ea0fec63dd79.js","mappings":"wJGWcA,EAKJA,EALIA,6CHVP,OACP,iBACA,8BACA,sBACA,WACA,gBACA,gBACA,gBACA,aACA,aACA,aACG,CACH,WACA,mDACA,sBACA,qBACA,0BACG,CACH,UACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,IACA,SACA,KACA,IACA,MACA,OACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,IACA,KACA,KACA,QACA,QACA,QACA,QACA,aACA,KACA,KACA,KACA,MACA,IACA,OACA,MACA,KACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,SACA,UACA,UACA,UACA,SACA,aACA,OACA,MACA,OACA,MACA,OACA,QACA,OACA,OACA,MACA,QACA,CACA,YACA,WACA,uBACA,OACA,oBACA,gBACA,CACA,oCACA,6BACA,oBACA,aACA,aACA,WACA,KACA,OACA,SACA,gBACA,YACA,SACA,QACA,MACA,kBACA,aACA,YACA,iBACA,OACA,SACA,cACA,cACA,OACA,UACA,UACA,UACA,QACA,OACA,UACA,QACA,UACA,SACA,WACA,MACA,WACA,UACA,UACA,QACA,UACA,SACA,WACA,SACA,QACA,KACA,QACA,OACA,YACA,QACA,SACA,WACA,OACA,SACA,UACA,SACA,OACA,SACA,WACA,MACA,MACA,OACA,UACA,QACA,QACA,WACA,QACA,OACA,OACA,QACA,UACA,WACA,SACA,QACA,OACA,SACA,SACA,QACA,SACA,QACA,WAEA,CAAG,CACH,UACA,OACA,gBACA,WACA,CACA,CACA,EC9HA,IAAc,gBAGd,GACA,MAAS,SAAU,CAAG,CAAC,CACvB,QAwJA,YACA,wBAAiC,QAAyB,MAC1D,EAzJA,QA4JA,YACA,wBAAiC,SAA2B,MAC5D,EA7JA,SACA,UACA,WAqKA,kBACA,IAcA,EAdA,qBAEA,mBAEA,iBACA,QACA,gBACA,EAAM,CACN,UACA,2BAGA,KAIA,WACA,gBACA,IAEA,EAFA,OAIA,eACA,gBA8OA,EA7OQ,MA6OR,EA7OQ,GA8OR,+CA9OQ,mBAG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","sources":["webpack://_N_E/../../node_modules/hast-util-sanitize/lib/schema.js","webpack://_N_E/../../node_modules/hast-util-sanitize/lib/index.js","webpack://_N_E/../../node_modules/rehype-sanitize/index.js","webpack://_N_E/../ui-core/src/ui/MarkdownWithPlugins.tsx","webpack://_N_E/../ui-core/node_modules/highlight.js/styles/github.css?4e9e"],"sourcesContent":["/** @type {import('./index.js').Schema} */\nexport const defaultSchema = {\n  strip: ['script'],\n  clobberPrefix: 'user-content-',\n  clobber: ['name', 'id'],\n  ancestors: {\n    tbody: ['table'],\n    tfoot: ['table'],\n    thead: ['table'],\n    td: ['table'],\n    th: ['table'],\n    tr: ['table']\n  },\n  protocols: {\n    href: ['http', 'https', 'mailto', 'xmpp', 'irc', 'ircs'],\n    cite: ['http', 'https'],\n    src: ['http', 'https'],\n    longDesc: ['http', 'https']\n  },\n  tagNames: [\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'br',\n    'b',\n    'i',\n    'strong',\n    'em',\n    'a',\n    'pre',\n    'code',\n    'img',\n    'tt',\n    'div',\n    'ins',\n    'del',\n    'sup',\n    'sub',\n    'p',\n    'ol',\n    'ul',\n    'table',\n    'thead',\n    'tbody',\n    'tfoot',\n    'blockquote',\n    'dl',\n    'dt',\n    'dd',\n    'kbd',\n    'q',\n    'samp',\n    'var',\n    'hr',\n    'ruby',\n    'rt',\n    'rp',\n    'li',\n    'tr',\n    'td',\n    'th',\n    's',\n    'strike',\n    'summary',\n    'details',\n    'caption',\n    'figure',\n    'figcaption',\n    'abbr',\n    'bdo',\n    'cite',\n    'dfn',\n    'mark',\n    'small',\n    'span',\n    'time',\n    'wbr',\n    'input'\n  ],\n  attributes: {\n    a: ['href'],\n    img: ['src', 'longDesc'],\n    input: [\n      ['type', 'checkbox'],\n      ['disabled', true]\n    ],\n    li: [['className', 'task-list-item']],\n    div: ['itemScope', 'itemType'],\n    blockquote: ['cite'],\n    del: ['cite'],\n    ins: ['cite'],\n    q: ['cite'],\n    '*': [\n      'abbr',\n      'accept',\n      'acceptCharset',\n      'accessKey',\n      'action',\n      'align',\n      'alt',\n      'ariaDescribedBy',\n      'ariaHidden',\n      'ariaLabel',\n      'ariaLabelledBy',\n      'axis',\n      'border',\n      'cellPadding',\n      'cellSpacing',\n      'char',\n      'charOff',\n      'charSet',\n      'checked',\n      'clear',\n      'cols',\n      'colSpan',\n      'color',\n      'compact',\n      'coords',\n      'dateTime',\n      'dir',\n      'disabled',\n      'encType',\n      'htmlFor',\n      'frame',\n      'headers',\n      'height',\n      'hrefLang',\n      'hSpace',\n      'isMap',\n      'id',\n      'label',\n      'lang',\n      'maxLength',\n      'media',\n      'method',\n      'multiple',\n      'name',\n      'noHref',\n      'noShade',\n      'noWrap',\n      'open',\n      'prompt',\n      'readOnly',\n      'rel',\n      'rev',\n      'rows',\n      'rowSpan',\n      'rules',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'span',\n      'start',\n      'summary',\n      'tabIndex',\n      'target',\n      'title',\n      'type',\n      'useMap',\n      'vAlign',\n      'value',\n      'vSpace',\n      'width',\n      'itemProp'\n    ]\n  },\n  required: {\n    input: {\n      type: 'checkbox',\n      disabled: true\n    }\n  }\n}\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Content | Root} Node\n *\n * @typedef {Properties[string]} PropertyValue\n *   Possible property values.\n * @typedef {string | number | boolean} PrimitivePropertyValue\n *   Possible primitive HTML attribute values.\n *\n * @typedef {Record<string, Array<string | [string, ...Array<PrimitivePropertyValue | RegExp>]>>} Attributes\n *  Map of tag names to allow lists for each property.\n * @typedef {Record<string, Array<PrimitivePropertyValue | RegExp>>} AttributeClean\n *   Normalized input.\n *\n * @typedef Schema\n *   Sanitization configuration.\n * @property {Attributes | undefined} [attributes]\n *   Map of tag names to allowed properties.\n *\n *   The special `'*'` key defines property names allowed on all elements.\n * @property {Record<string, Record<string, PropertyValue>> | undefined} [required]\n *   Map of tag names to required property names and their default property value.\n * @property {Array<string> | undefined} [tagNames]\n *   List of allowed tag names.\n * @property {Record<string, Array<string>> | undefined} [protocols]\n *   Map of protocols to allow in property values.\n * @property {Record<string, Array<string>> | undefined} [ancestors]\n *   Map of tag names to their required ancestor elements.\n * @property {Array<string> | undefined} [clobber]\n *   List of allowed property names which can clobber.\n * @property {string | undefined} [clobberPrefix]\n *   Prefix to use before potentially clobbering property names.\n * @property {Array<string> | undefined} [strip]\n *   Names of elements to strip from the tree.\n * @property {boolean | undefined} [allowComments]\n *   Whether to allow comments.\n * @property {boolean | undefined} [allowDoctypes]\n *   Whether to allow doctypes.\n *\n * @typedef {(schema: Schema, value: any, node: any, stack: Array<string>) => unknown} Handler\n * @typedef {Record<string, Handler>} NodeDefinition\n * @typedef {((schema: Schema, node: Node) => NodeDefinition | undefined)} NodeDefinitionGetter\n * @typedef {Record<string, NodeDefinition | NodeDefinitionGetter>} NodeSchema\n */\n\nimport {defaultSchema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {NodeSchema} */\nconst nodeSchema = {\n  root: {children: all},\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {value: handleValue},\n  '*': {data: allow, position: allow}\n}\n\n/**\n * Utility to sanitize a tree\n *\n * @param {Node} node\n *   Hast tree to sanitize\n * @param {Schema} [schema]\n *   Schema defining how to sanitize - defaults to Github style sanitation\n */\nexport function sanitize(node, schema) {\n  /** @type {Node} */\n  let ctx = {type: 'root', children: []}\n\n  if (node && typeof node === 'object' && node.type) {\n    const replace = one(\n      Object.assign({}, defaultSchema, schema || {}),\n      node,\n      []\n    )\n\n    if (replace) {\n      if (Array.isArray(replace)) {\n        if (replace.length === 1) {\n          ctx = replace[0]\n        } else {\n          // @ts-expect-error Assume `root` is not a child.\n          ctx.children = replace\n        }\n      } else {\n        ctx = replace\n      }\n    }\n  }\n\n  return ctx\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {Schema} schema\n * @param {Node} node\n * @param {Array<string>} stack\n * @returns {Node | Array<Node> | undefined}\n */\nfunction one(schema, node, stack) {\n  const type = node && node.type\n  /** @type {Node} */\n  // @ts-expect-error rest of props added later.\n  const replacement = {type: node.type}\n  /** @type {boolean | undefined} */\n  let replace\n\n  if (own.call(nodeSchema, type)) {\n    /** @type {NodeDefinition | NodeDefinitionGetter | undefined} */\n    let definition = nodeSchema[type]\n\n    if (typeof definition === 'function') {\n      definition = definition(schema, node)\n    }\n\n    if (definition) {\n      const allowed = Object.assign({}, definition, nodeSchema['*'])\n      /** @type {string} */\n      let key\n\n      replace = true\n\n      for (key in allowed) {\n        if (own.call(allowed, key)) {\n          // @ts-expect-error: fine.\n          // type-coverage:ignore-next-line\n          const result = allowed[key](schema, node[key], node, stack)\n\n          // eslint-disable-next-line max-depth\n          if (result === false) {\n            replace = undefined\n            // Set the non-safe value.\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = node[key]\n          } else if (result !== undefined && result !== null) {\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = result\n          }\n        }\n      }\n    }\n  }\n\n  if (replace) {\n    return replacement\n  }\n\n  return replacement.type === 'element' &&\n    schema.strip &&\n    !schema.strip.includes(replacement.tagName)\n    ? replacement.children\n    : undefined\n}\n\n/**\n * Sanitize `children`.\n *\n * @type {Handler}\n * @param {Array<Node>} children\n * @param {Node} node\n * @returns {Array<Node>}\n */\nfunction all(schema, children, node, stack) {\n  /** @type {Array<Node>} */\n  const results = []\n\n  if (Array.isArray(children)) {\n    let index = -1\n\n    if (node.type === 'element') {\n      stack.push(node.tagName)\n    }\n\n    while (++index < children.length) {\n      const value = one(schema, children[index], stack)\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value)\n        } else {\n          results.push(value)\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      stack.pop()\n    }\n  }\n\n  return results\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {name: handleDoctypeName} : undefined\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleComment(schema) {\n  return schema.allowComments ? {value: handleCommentValue} : undefined\n}\n\n/**\n * Sanitize `properties`.\n *\n * @type {Handler}\n * @param {Properties} properties\n * @param {Element} node\n * @returns {Properties}\n */\nfunction handleProperties(schema, properties, node, stack) {\n  const name = handleTagName(schema, node.tagName, node, stack)\n  /* c8 ignore next */\n  const attrs = schema.attributes || {}\n  /* c8 ignore next */\n  const reqs = schema.required || {}\n  const props = properties || {}\n  const allowed = Object.assign(\n    {},\n    toPropertyValueMap(attrs['*']),\n    toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : [])\n  )\n  /** @type {Properties} */\n  const result = {}\n  /** @type {string} */\n  let key\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      let value = props[key]\n      /** @type {AttributeClean[string]} */\n      let definition\n\n      if (own.call(allowed, key)) {\n        definition = allowed[key]\n      } else if (data(key) && own.call(allowed, 'data*')) {\n        definition = allowed['data*']\n      } else {\n        continue\n      }\n\n      value = Array.isArray(value)\n        ? handlePropertyValues(schema, value, key, definition)\n        : handlePropertyValue(schema, value, key, definition)\n\n      if (value !== undefined && value !== null) {\n        result[key] = value\n      }\n    }\n  }\n\n  if (name && own.call(reqs, name)) {\n    for (key in reqs[name]) {\n      if (!own.call(result, key)) {\n        result[key] = reqs[name][key]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Always return a valid HTML5 doctype.\n *\n * @type {Handler}\n * @returns {string}\n */\nfunction handleDoctypeName() {\n  return 'html'\n}\n\n/**\n * Sanitize `tagName`.\n *\n * @param {Schema} schema\n * @param {string} tagName\n * @param {Node} _\n * @param {Array<string>} stack\n * @returns {string | false}\n */\nfunction handleTagName(schema, tagName, _, stack) {\n  const name = typeof tagName === 'string' ? tagName : ''\n  let index = -1\n\n  if (\n    !name ||\n    name === '*' ||\n    (schema.tagNames && !schema.tagNames.includes(name))\n  ) {\n    return false\n  }\n\n  // Some nodes can break out of their context if they don’t have a certain\n  // ancestor.\n  if (schema.ancestors && own.call(schema.ancestors, name)) {\n    while (++index < schema.ancestors[name].length) {\n      if (stack.includes(schema.ancestors[name][index])) {\n        return name\n      }\n    }\n\n    return false\n  }\n\n  return name\n}\n\n/**\n * See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleCommentValue(_, value) {\n  /** @type {string} */\n  const result = typeof value === 'string' ? value : ''\n  const index = result.indexOf('-->')\n  return index < 0 ? result : result.slice(0, index)\n}\n\n/**\n * Sanitize `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleValue(_, value) {\n  return typeof value === 'string' ? value : ''\n}\n\n/**\n * Allow `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n */\nfunction allow(_, value) {\n  return value\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {Schema} schema\n * @param {Array<unknown>} values\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {Array<string | number>}\n */\nfunction handlePropertyValues(schema, values, prop, definition) {\n  let index = -1\n  /** @type {Array<string | number>} */\n  const result = []\n\n  while (++index < values.length) {\n    const value = handlePropertyValue(schema, values[index], prop, definition)\n\n    if (value !== undefined && value !== null) {\n      // @ts-expect-error Assume no booleans were in arrays.\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {PropertyValue}\n */\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if (\n    (typeof value === 'boolean' ||\n      typeof value === 'number' ||\n      typeof value === 'string') &&\n    safeProtocol(schema, value, prop) &&\n    (definition.length === 0 ||\n      definition.some((allowed) =>\n        allowed && typeof allowed === 'object' && 'flags' in allowed\n          ? allowed.test(String(value))\n          : allowed === value\n      ))\n  ) {\n    return schema.clobberPrefix &&\n      schema.clobber &&\n      schema.clobber.includes(prop)\n      ? schema.clobberPrefix + value\n      : value\n  }\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @returns {boolean}\n */\nfunction safeProtocol(schema, value, prop) {\n  const url = String(value)\n  const colon = url.indexOf(':')\n  const questionMark = url.indexOf('?')\n  const numberSign = url.indexOf('#')\n  const slash = url.indexOf('/')\n  const protocols =\n    schema.protocols && own.call(schema.protocols, prop)\n      ? schema.protocols[prop].concat()\n      : []\n  let index = -1\n\n  if (\n    protocols.length === 0 ||\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign)\n  ) {\n    return true\n  }\n\n  while (++index < protocols.length) {\n    if (\n      colon === protocols[index].length &&\n      url.slice(0, protocols[index].length) === protocols[index]\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Create a map from a list of props or a list of properties and values.\n *\n * @param {Attributes[string]} values\n * @returns {AttributeClean}\n */\nfunction toPropertyValueMap(values) {\n  /** @type {AttributeClean} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    const value = values[index]\n\n    if (Array.isArray(value)) {\n      result[value[0]] = value.slice(1)\n    } else {\n      result[value] = []\n    }\n  }\n\n  return result\n}\n\n/**\n * Check if `prop` is a data property.\n *\n * @param {string} prop\n * @returns {boolean}\n */\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data'\n}\n","/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('hast-util-sanitize').Schema} Options\n *   The sanitation schema defines how and if nodes and properties should be cleaned.\n *   See `hast-util-sanitize`.\n *   The default schema is exported as `defaultSchema`.\n */\n\nimport {sanitize as hastUtilSanitize, defaultSchema} from 'hast-util-sanitize'\n\n/**\n * Plugin to sanitize HTML.\n *\n * @type {import('unified').Plugin<[Options?] | Array<void>, Root, Root>}\n */\nexport default function rehypeSanitize(options = defaultSchema) {\n  // @ts-expect-error: assume input `root` matches output root.\n  return (tree) => hastUtilSanitize(tree, options)\n}\n\nexport {defaultSchema} from 'hast-util-sanitize'\n","import {Colors} from '@dagster-io/ui-components';\nimport ReactMarkdown from 'react-markdown';\nimport rehypeHighlight from 'rehype-highlight';\nimport rehypeSanitize, {defaultSchema} from 'rehype-sanitize';\nimport gfm from 'remark-gfm';\nimport {createGlobalStyle} from 'styled-components';\nimport 'highlight.js/styles/github.css';\n\nconst sanitizeConfig = {\n  ...defaultSchema,\n  protocols: {\n    src: [...(defaultSchema.protocols?.src ?? []), 'data'],\n  },\n  attributes: {\n    ...defaultSchema.attributes,\n    span: [\n      ...(defaultSchema.attributes?.span || []),\n      // List of all allowed tokens:\n      [\n        'className',\n        'hljs-addition',\n        'hljs-attr',\n        'hljs-attribute',\n        'hljs-built_in',\n        'hljs-bullet',\n        'hljs-char',\n        'hljs-code',\n        'hljs-comment',\n        'hljs-deletion',\n        'hljs-doctag',\n        'hljs-emphasis',\n        'hljs-formula',\n        'hljs-keyword',\n        'hljs-link',\n        'hljs-literal',\n        'hljs-meta',\n        'hljs-name',\n        'hljs-number',\n        'hljs-operator',\n        'hljs-params',\n        'hljs-property',\n        'hljs-punctuation',\n        'hljs-quote',\n        'hljs-regexp',\n        'hljs-section',\n        'hljs-selector-attr',\n        'hljs-selector-class',\n        'hljs-selector-id',\n        'hljs-selector-pseudo',\n        'hljs-selector-tag',\n        'hljs-string',\n        'hljs-strong',\n        'hljs-subst',\n        'hljs-symbol',\n        'hljs-tag',\n        'hljs-template-tag',\n        'hljs-template-variable',\n        'hljs-title',\n        'hljs-type',\n        'hljs-variable',\n      ],\n    ],\n  },\n};\n\nconst GlobalStyle = createGlobalStyle`\n  .dagster-markdown {\n    .hljs-doctag,\n    .hljs-keyword,\n    .hljs-meta .hljs-keyword,\n    .hljs-template-tag,\n    .hljs-template-variable,\n    .hljs-type,\n    .hljs-variable.language_ {\n      color: ${Colors.textBlue()}\n    }\n\n    .hljs-title,\n    .hljs-title.class_,\n    .hljs-title.class_.inherited__,\n    .hljs-title.function_ {\n      color: ${Colors.textBlue()};\n    }\n\n    .hljs-attr,\n    .hljs-attribute,\n    .hljs-literal,\n    .hljs-meta,\n    .hljs-number,\n    .hljs-operator,\n    .hljs-selector-attr,\n    .hljs-selector-class,\n    .hljs-selector-id,\n    .hljs-variable {\n      color: ${Colors.textLight()};\n    }\n\n    .hljs-meta .hljs-string,\n    .hljs-regexp,\n    .hljs-string {\n      color: ${Colors.textCyan()};\n    }\n\n    .hljs-built_in,\n    .hljs-symbol {\n      color: ${Colors.textYellow()};\n    }\n\n    .hljs-code,\n    .hljs-comment,\n    .hljs-formula {\n      color: ${Colors.textLight()};\n    }\n\n    .hljs-name,\n    .hljs-quote,\n    .hljs-selector-pseudo,\n    .hljs-selector-tag {\n      color: ${Colors.textGreen()};\n    }\n  }\n`;\n\ninterface Props {\n  children: string;\n}\n\nexport const MarkdownWithPlugins = (props: Props) => {\n  return (\n    <>\n      <GlobalStyle />\n      <ReactMarkdown\n        {...props}\n        className=\"dagster-markdown\"\n        remarkPlugins={[gfm]}\n        rehypePlugins={[\n          [rehypeHighlight, {ignoreMissing: true}],\n          [rehypeSanitize, sanitizeConfig],\n        ]}\n      />\n    </>\n  );\n};\n\n// eslint-disable-next-line import/no-default-export\nexport default MarkdownWithPlugins;\n","// extracted by mini-css-extract-plugin"],"names":["defaultSchema","sanitizeConfig","protocols","src","attributes","span","GlobalStyle","createGlobalStyle","Colors","MarkdownWithPlugins","props","ReactMarkdown","className","remarkPlugins","gfm","rehypePlugins","rehypeHighlight","ignoreMissing","rehypeSanitize"],"sourceRoot":"","ignoreList":[0,1,2,4]}